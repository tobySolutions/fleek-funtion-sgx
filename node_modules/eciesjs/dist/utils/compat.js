"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.aes256cbc = exports.aes256gcm = void 0;
var utils_1 = require("@noble/ciphers/utils");
var crypto_1 = require("crypto");
var consts_1 = require("../consts");
var aes256gcm = function (key, nonce, AAD) { return _compatAES("aes-256-gcm", key, nonce, AAD); };
exports.aes256gcm = aes256gcm;
// NOT RECOMMENDED. There is neither AAD nor AEAD tag in cbc mode
var aes256cbc = function (key, nonce, AAD) { return _compatAES("aes-256-cbc", key, nonce); };
exports.aes256cbc = aes256cbc;
// make `node:crypto`'s aes compatible with `@noble/ciphers`
function _compatAES(algorithm, key, nonce, AAD) {
    var isAEAD = algorithm === "aes-256-gcm";
    var tagLength = isAEAD ? consts_1.AEAD_TAG_LENGTH : 0;
    var encrypt = function (plainText) {
        var cipher = (0, crypto_1.createCipheriv)(algorithm, key, nonce);
        if (isAEAD && AAD) {
            cipher.setAAD(AAD);
        }
        var updated = cipher.update(plainText);
        var finalized = cipher.final();
        if (isAEAD) {
            return (0, utils_1.concatBytes)(updated, finalized, cipher.getAuthTag());
        }
        return (0, utils_1.concatBytes)(updated, finalized);
    };
    var decrypt = function (cipherText) {
        var encrypted = cipherText.subarray(0, cipherText.length - tagLength);
        var tag = cipherText.subarray(cipherText.length - tagLength);
        var decipher = (0, crypto_1.createDecipheriv)(algorithm, key, nonce);
        if (isAEAD) {
            if (AAD) {
                decipher.setAAD(AAD);
            }
            decipher.setAuthTag(tag);
        }
        var updated = decipher.update(encrypted);
        var finalized = decipher.final();
        return (0, utils_1.concatBytes)(updated, finalized);
    };
    return {
        encrypt: encrypt,
        decrypt: decrypt,
    };
}
