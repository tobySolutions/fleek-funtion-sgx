"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveKey = exports.aesDecrypt = exports.aesEncrypt = exports.symDecrypt = exports.symEncrypt = void 0;
var chacha_1 = require("@noble/ciphers/chacha");
var utils_1 = require("@noble/ciphers/utils");
var webcrypto_1 = require("@noble/ciphers/webcrypto");
var hkdf_1 = require("@noble/hashes/hkdf");
var sha256_1 = require("@noble/hashes/sha256");
var config_1 = require("../config");
var consts_1 = require("../consts");
var compat_1 = require("./compat");
var symEncrypt = function (key, plainText) {
    return _exec(true, key, plainText);
};
exports.symEncrypt = symEncrypt;
var symDecrypt = function (key, cipherText) {
    return _exec(false, key, cipherText);
};
exports.symDecrypt = symDecrypt;
/** @deprecated - use `symEncrypt` instead. */
exports.aesEncrypt = exports.symEncrypt; // TODO: delete
/** @deprecated - use `symDecrypt` instead. */
exports.aesDecrypt = exports.symDecrypt; // TODO: delete
var deriveKey = function (master) {
    // 32 bytes shared secret for aes256 and xchacha20 derived from HKDF-SHA256
    return (0, hkdf_1.hkdf)(sha256_1.sha256, master, undefined, undefined, 32);
};
exports.deriveKey = deriveKey;
function _exec(is_encryption, key, data) {
    var algorithm = (0, config_1.symmetricAlgorithm)();
    var callback = is_encryption ? _encrypt : _decrypt;
    if (algorithm === "aes-256-gcm") {
        return callback(compat_1.aes256gcm, key, data, (0, config_1.symmetricNonceLength)());
    }
    else if (algorithm === "xchacha20") {
        return callback(chacha_1.xchacha20poly1305, key, data, consts_1.XCHACHA20_NONCE_LENGTH);
    }
    else if (algorithm === "aes-256-cbc") {
        // aes-256-cbc is always 16 bytes iv and there is no AEAD tag
        return callback(compat_1.aes256cbc, key, data, 16, 0);
    }
    else {
        throw new Error("Not implemented");
    }
}
function _encrypt(func, key, plainText, nonceLength, tagLength) {
    if (tagLength === void 0) { tagLength = consts_1.AEAD_TAG_LENGTH; }
    var nonce = (0, webcrypto_1.randomBytes)(nonceLength);
    var cipher = func(key, nonce);
    var ciphered = cipher.encrypt(plainText); // encrypted || tag
    var encrypted = ciphered.subarray(0, ciphered.length - tagLength);
    var tag = ciphered.subarray(ciphered.length - tagLength);
    return (0, utils_1.concatBytes)(nonce, tag, encrypted);
}
function _decrypt(func, key, cipherText, nonceLength, tagLength) {
    if (tagLength === void 0) { tagLength = consts_1.AEAD_TAG_LENGTH; }
    var nonceTagLength = nonceLength + tagLength;
    var nonce = cipherText.subarray(0, nonceLength);
    var tag = cipherText.subarray(nonceLength, nonceTagLength);
    var encrypted = cipherText.subarray(nonceTagLength);
    var decipher = func(key, Uint8Array.from(nonce)); // to reset byteOffset
    var ciphered = (0, utils_1.concatBytes)(encrypted, tag);
    return decipher.decrypt(ciphered);
}
