"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployActionHandler = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const cli_progress_1 = __importDefault(require("cli-progress"));
const hash_wasm_1 = require("hash-wasm");
const cli_1 = require("../../cli");
const withGuards_1 = require("../../guards/withGuards");
const uploadOnProgress_1 = require("../../output/utils/uploadOnProgress");
const translation_1 = require("../../utils/translation");
const getFunctionOrPrompt_1 = require("./prompts/getFunctionOrPrompt");
const getFunctionPathOrPrompt_1 = require("./prompts/getFunctionPathOrPrompt");
const getJsCodeFromPath_1 = require("./utils/getJsCodeFromPath");
const parseEnvironmentVariables_1 = require("./utils/parseEnvironmentVariables");
const waitUntilFileAvailable_1 = require("./wait/waitUntilFileAvailable");
const getWasmCodeFromPath_1 = require("./utils/getWasmCodeFromPath");
const deployAction = async ({ sdk, args, }) => {
    const env = (0, parseEnvironmentVariables_1.getEnvironmentVariables)({ env: args.env, envFile: args.envFile });
    const functionToDeploy = await (0, getFunctionOrPrompt_1.getFunctionOrPrompt)({ name: args.name, sdk });
    const filePath = await (0, getFunctionPathOrPrompt_1.getFunctionPathOrPrompt)({ path: args.filePath });
    const bundle = !args.noBundle;
    const sgx = args.sgx ?? false;
    if (args.private && sgx) {
        cli_1.output.error((0, translation_1.t)('pvtFunctionInSgxNotSupported', { name: 'function' }));
        return;
    }
    if (!functionToDeploy) {
        cli_1.output.error((0, translation_1.t)('expectedNotFoundGeneric', { name: 'function' }));
        return;
    }
    const filePathToUpload = sgx ? await (0, getWasmCodeFromPath_1.getWasmCodeFromPath)({ filePath })
        : await (0, getJsCodeFromPath_1.getJsCodeFromPath)({
            filePath,
            bundle,
            env,
        });
    cli_1.output.printNewLine();
    const progressBar = new cli_progress_1.default.SingleBar({
        format: (0, translation_1.t)('uploadProgress', { action: (0, translation_1.t)('uploadCodeToIpfs') }),
    }, cli_progress_1.default.Presets.shades_grey);
    let uploadResult;
    if (args.private) {
        uploadResult = await sdk.storage().uploadPrivateFile({
            filePath: filePathToUpload,
            onUploadProgress: (0, uploadOnProgress_1.uploadOnProgress)(progressBar),
        });
    }
    else {
        const fileLikeObject = await (0, getJsCodeFromPath_1.getFileLikeObject)(filePathToUpload);
        uploadResult = await sdk.storage().uploadFile({
            file: fileLikeObject,
            options: { functionName: functionToDeploy.name },
            onUploadProgress: (0, uploadOnProgress_1.uploadOnProgress)(progressBar),
        });
    }
    let b3Hash;
    if (sgx) {
        const buffer = await node_fs_1.default.promises.readFile(filePathToUpload);
        b3Hash = await (0, hash_wasm_1.blake3)(buffer);
    }
    if (!cli_1.output.debugEnabled && !args.noBundle) {
        node_fs_1.default.rmSync(filePathToUpload);
    }
    if (!uploadResult.pin.cid) {
        cli_1.output.error((0, translation_1.t)('commonFunctionActionFailure', {
            action: 'deploy',
            tryAgain: (0, translation_1.t)('tryAgain'),
            message: (0, translation_1.t)('uploadToIpfsFailed'),
        }));
        return;
    }
    if (uploadResult.duplicate &&
        functionToDeploy.currentDeployment &&
        uploadResult.pin &&
        functionToDeploy.currentDeployment.cid === uploadResult.pin.cid) {
        cli_1.output.chore((0, translation_1.t)('noChangesDetected'));
        return;
    }
    if (!args.private) {
        cli_1.output.printNewLine();
        cli_1.output.spinner((0, translation_1.t)('runningAvailabilityCheck'));
        const isAvailable = await (0, waitUntilFileAvailable_1.waitUntilFileAvailable)({
            cid: uploadResult.pin.cid,
        });
        if (!isAvailable) {
            cli_1.output.error((0, translation_1.t)('availabilityCheckFailed'));
            return;
        }
    }
    await sdk.functions().deploy({
        functionId: functionToDeploy.id,
        cid: uploadResult.pin.cid,
        sgx,
        blake3Hash: b3Hash ?? undefined,
    });
    if (sgx) {
        // We need to make a request to the network so the network can have a mapping to the blake3 hash.
        // this is a temporarily hack until dalton comes up with a fix on network
        cli_1.output.spinner((0, translation_1.t)('networkFetchMappings'));
        try {
            await (0, node_fetch_1.default)(`https://fleek-test.network/services/0/ipfs/${uploadResult.pin.cid}`);
        }
        catch {
            cli_1.output.error((0, translation_1.t)('networkFetchFailed'));
            return;
        }
    }
    cli_1.output.success((0, translation_1.t)('commonNameCreateSuccess', { name: 'deployment' }));
    cli_1.output.printNewLine();
    cli_1.output.log((0, translation_1.t)('callFleekFunctionByUrlReq'));
    cli_1.output.link(functionToDeploy.invokeUrl);
    if (sgx) {
        cli_1.output.log((0, translation_1.t)('callFleekFunctionByNetworkUrlReq'));
        cli_1.output.link("https://fleek-test.network/services/3");
        cli_1.output.printNewLine();
        cli_1.output.link(`Blake3 Hash: ${b3Hash} `);
        cli_1.output.link(`Invoke by sending request to https://fleek-test.network/services/3 with payload of {hash: <Blake3Hash>, decrypt: true, inputs: "foo"}`);
        cli_1.output.link(`Example: curl fleek-test.network/services/3 --data '{"hash": "${b3Hash}", "decrypt": true, "input": "foo"}'`);
    }
    else {
        if (!args.private) {
            cli_1.output.log((0, translation_1.t)('callFleekFunctionByNetworkUrlReq'));
            cli_1.output.link(`https://fleek-test.network/services/1/ipfs/${uploadResult.pin.cid}`);
        }
    }
};
exports.deployActionHandler = (0, withGuards_1.withGuards)(deployAction, {
    scopes: {
        authenticated: true,
        project: true,
        site: false,
    },
});
//# sourceMappingURL=deploy.js.map